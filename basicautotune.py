# -*- coding: utf-8 -*-
"""

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DN1YLRhShTDTtCNV9ZQTKfcGz5tCdNck

pip install wavio

pip install audio2numpy
"""

!pip install wavio
!pip install audio2numpy

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import wavio
from audio2numpy import open_audio

"""# Punto 4.4-Auto-tuner

Para el auto-tuner se usará la propiedad de translacion en el dominio de la frecuencia tal como se indica en el libro de Digital Signal Processing de John. G Proakis y Dimitris G. Manolakis en la página 478:
$$
x(n)e^{j2\pi ln/N} \quad \longrightarrow \quad X(k-l)
$$
Inicialmente se usará la transformada de Fourier discreta para las pruebas inicial, pero en la aplicación se usará la transformada rápida de Fourier
"""

def FT_general_point(x,k,N):
    n = np.array(range(N))
    exps = np.exp(-1j*2*np.pi*k*n/N)
    return np.dot(x,exps)

def FT_general(x):
    N = x.shape[0]
    X = np.array([FT_general_point(x,k,N) for k in range(N)])
    return X

"""Se demuestra el correcto funcionamiento de la propiedad de translación en el dominio de la frecuencia con una señal gaussiana tal como se muestra en las figuras:"""

fs = 100

a = 1
n = np.arange(-10, 10, 1/fs)

samples = n.shape[0]

x = np.exp(-a*np.power(n,2)) 

fig, (ax0, ax1) = plt.subplots(ncols = 2,
                               constrained_layout = True,
                               figsize = (12,4))

ax0.plot(n, x)
ax0.set_title('Dominio Temporal')
ax0.grid()
ax0.set_xlabel('Tiempo')

X = FT_general(x)
Mg = np.abs(X)

ax1.plot(np.linspace(0,fs,x.shape[0])[0:int(x.shape[0]/2)],Mg[0:int(x.shape[0]/2)])
ax1.set_title('DFT')
ax1.grid()
ax1.set_xlabel('Frecuencia');

"""Se desplaza la frecuencia 30 Hz"""

f0 = 30
x = np.exp(2j*np.pi*f0*n)*x

X = FT_general(x)
Mg = np.abs(X)

fig, ax = plt.subplots(figsize = (8,4))

ax.plot(np.linspace(0,fs,x.shape[0])[0:int(x.shape[0]/2)],Mg[0:int(x.shape[0]/2)])
ax.set_title('DFT')
ax.grid()
ax.set_xlabel('Frecuencia');

"""Se desplaza la frecuencia -15 Hz"""

f0 = -15
x = np.exp(2j*np.pi*f0*n)*x

X = FT_general(x)
Mg = np.abs(X)

fig, ax = plt.subplots(figsize = (8,4))

ax.plot(np.linspace(0,fs,x.shape[0])[0:int(x.shape[0]/2)],Mg[0:int(x.shape[0]/2)])
ax.set_title('DFT')
ax.grid()
ax.set_xlabel('Frecuencia');

"""Estos ejemplos muestran que el desplazamiento en frecuencia fue implementado correctamente. Ahora se aplicará a señales de audio reales.

## Descripcion Audios

A continuación dos audios serán editados para que sigan la melodía Do, Mi, Sol, Do, Sol, Mi, Do. Los audios tiene valores de frecuencia cercanos a los deseados para disminuir la distorsión que se crea cuando se cambia la frecuencia de las secciones de las señales de audios. Las frecuencias de las notas musicales deseadas son las siguientes:

|Nota|Frecuencia (Hz)|
|---|---|
|Do3|130.81|
|Mi3|164.81|
|Sol3|196.00|
|Do4|261.63|

Fuente:
https://pages.mtu.edu/~suits/notefreqs.html

## Audio 1 (Voz)

Se carga la señal de audio llamada "aud1.mp3"
"""

signal, sampling_rate = open_audio('/content/aud1.mp3')
total_size = signal.shape[0]
t = np.arange(0, total_size/sampling_rate, 1/sampling_rate)
inds = np.arange(0,total_size)

signal_cambiada_real = signal.copy()
signal_cambiada_im = signal.copy()
print("sampling rate:",sampling_rate)

"""Se grafica la señal de audio en el tiempo. Esto es para identificar la ubicación en el array de cada una de las secciones."""

ini = 0
fin = total_size

fig, (ax0, ax1) = plt.subplots(nrows=2, constrained_layout=True, figsize = (12,10))

Mg = np.abs(signal)

ax0.plot(inds[ini:fin],Mg[ini:fin])
ax0.set_xlabel('Indice')
ax0.grid();

ax1.plot(t[ini:fin],Mg[ini:fin])
ax1.set_xlabel('Tiempo (s)')
ax1.grid();

"""Una vez se tienen los índices de las secciones identificados, se procede a mirar el espectro de frecuencia por cada sección e identificar su componente más significativo."""

secs = [
    [18000, 33500],
    [35000, 48500],
    [50800, 64300],
    [66500, 80600],
    [81800, 95000],
    [96600, 110000],
    [112500, 130000]
]

signal, sampling_rate = open_audio('/content/aud1.mp3')

num_secs = len(secs)

frecuencias = []

fig = plt.figure(constrained_layout=True, figsize = (12,20))

gs = gridspec.GridSpec(num_secs, 2, figure=fig)

for i in range(num_secs):

    ax0 = fig.add_subplot(gs[i, 0])
    ax1 = fig.add_subplot(gs[i, 1])

    subsignal = signal[secs[i][0]:secs[i][1]]
    Subsignal = np.fft.fft(subsignal)[1:800]
    f = np.linspace(0,sampling_rate,subsignal.shape[0])[1:800]
    ic = np.argmax(np.abs(Subsignal))
    fc = f[ic]
    frecuencias.append(fc)

    ax0.plot(t[secs[i][0]:secs[i][1]],np.abs(subsignal))
    ax0.set_xlabel('Tiempo (s)')
    ax0.set_title('Seccion '+str(i+1))
    ax0.grid()

    ax1.plot(f,np.abs(Subsignal))
    ax1.set_xlabel('Frecuencia (Hz)')
    ax1.set_title('Frecuencia principal:'+str(fc)[:5])
    ax1.grid()

"""El desafinamiento se puede entonces corregir con la propiedad de desplazamiento de frecuencia. Primero se tiene que calcular el cambio deseado según la tabla de frecuencias después se aplica la propiedad. Una vez que cada sección a sido editada se guarda en las variables signal_cambiada_real y signal_cambiada_im."""

#CALCULE Y APLIQUE EL DESPLAZAMIENTO FRECUENCIAL
#GRAFIQUE EL ESPECTRO FRECUENCIAL ANTES Y DESPUES DEL DESPLAZAMIENTO 
#GRABE LA SEÑAL EN ESTEREO USANDO LA PARTE REAL PARA EL CANAL R Y LA PARTE IMAGINARIA PARA EL CANAL L.

!pip install wavio
!pip install audio2numpy

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import wavio
from audio2numpy import open_audio

#Frecuencias deseadas
f_deseadas = [
    130.81,
    164.81,
    196,
    261.63,
    196,
    164.81,
    130.81
]

#Ventanas de tiempo
secs = [
    [18000, 33500],
    [35000, 48500],
    [50800, 64300],
    [66500, 80600],
    [81800, 95000],
    [96600, 110000],
    [112500, 130000]
]

fig = plt.figure(constrained_layout=True, figsize = (12,20))

signal, sampling_rate = open_audio('/content/aud1.mp3')

total_size = signal.shape[0]
t = np.arange(0, total_size/sampling_rate, 1/sampling_rate)

num_secs = len(secs)
gs = gridspec.GridSpec(num_secs, 2, figure=fig)

frecuencias = []

signalFinal = signal

print(f_deseadas)

for i in range(num_secs):
    #Subplots
    ax0 = fig.add_subplot(gs[i, 0])
    ax1 = fig.add_subplot(gs[i, 1])

    #Identificacion de frecuencia principal sin desplazar
    subsignal = signal[secs[i][0]:secs[i][1]]
    Subsignal1 = np.fft.fft(subsignal)[1:800]
    f = np.linspace(0,sampling_rate,subsignal.shape[0])[1:800]
    ic = np.argmax(np.abs(Subsignal1))
    fc1 = f[ic]

    #Calculo de desplazamiento frecuencial
    delta=f_deseadas[i]-fc1

    #Desplazamiento frecuencial
    subsignal = np.exp(2j*np.pi*delta*t[secs[i][0]:secs[i][1]])*signal[secs[i][0]:secs[i][1]]
    Subsignal2 = np.fft.fft(subsignal)[1:800]

    #Identificacion de frecuencia principal desplazada
    f = np.linspace(0,sampling_rate,subsignal.shape[0])[1:800]
    ic = np.argmax(np.abs(Subsignal2))
    fc2 = f[ic]

    #Adicion de la parte desplazada en frecuencia a la señal final
    signalFinal[secs[i][0]:secs[i][1]]=subsignal

    #Adicion de frecuencia principal a lista
    frecuencias.append(fc2)

    # ax0.plot(t[secs[i][0]:secs[i][1]],np.abs(subsignal))
    # ax0.set_xlabel('Tiempo (s)')
    # ax0.set_title('Seccion '+str(i+1))
    # ax0.grid()

    #Grafica de espectro antes del desplazamiento
    ax0.plot(f,np.abs(Subsignal1))
    ax0.set_xlabel('Frecuencia (Hz)')
    ax0.set_ylabel('Magnitud')
    ax0.set_title('Espectro antes del desplazamiento, frecuencia principal:'+str(fc1)[:6])
    ax0.grid()

    #Grafica de espectro despues del desplazamiento
    ax1.plot(f,np.abs(Subsignal2))
    ax1.set_xlabel('Frecuencia (Hz)')
    ax1.set_ylabel('Magnitud')
    ax1.set_title('Espectro despues del desplazamiento, frecuencia principal:'+str(fc2)[:6])
    ax1.grid()

#Grafica de señal en tiempo despues del desplazamiento
plt.figure()
plt.plot(t,np.abs(signalFinal))
plt.xlabel('Tiempo (s)')
plt.title('Señal final')
plt.show()

#Grabacion de señal
wavio.write("aud1_cambiado.mp3", signalFinal, sampling_rate, sampwidth=1)
#TERMINE SU CODIGO AQUI

"""Finalmente se guarda la nueva señal de audio. La parte real e imaginaria serán cada uno de los canales.

## Audio 2 (Guitarra)

El proceso anterior se repite para el audio de la guitarra. Sin embargo, se debe tener en cuenta que  el componente de frecuencia con mayor energía no necesariamente es el de menor frecuencia.

> Indented block
"""

signal, sampling_rate = open_audio('/content/aud2.mp3')
total_size = signal.shape[0]
t2 = np.arange(0, total_size/sampling_rate, 1/sampling_rate)
inds2 = np.arange(0,total_size)

signal_cambiada_real = signal.copy()
signal_cambiada_im = signal.copy()

ini = 0
fin = total_size

fig, (ax0, ax1) = plt.subplots(nrows=2, constrained_layout=True, figsize = (12,10))

Mg = np.abs(signal)

ax0.plot(inds[ini:fin],Mg[ini:fin])
ax0.set_xlabel('Indice')
ax0.grid();

ax1.plot(t[ini:fin],Mg[ini:fin])
ax1.set_xlabel('Tiempo (s)')
ax1.grid();

secs = [
    [15000, 61000],
    [95000, 137000],
    [171000, 215000],
    [250000, 290000],
    [328000, 372000],
    [410000, 453000],
    [497000, 535000]
]

signal, sampling_rate = open_audio('/content/aud2.mp3')

num_secs = len(secs)

frecuencias = []

fig = plt.figure(constrained_layout=True, figsize = (12,20))

gs = gridspec.GridSpec(num_secs, 2, figure=fig)

for i in range(num_secs):

    ax0 = fig.add_subplot(gs[i, 0])
    ax1 = fig.add_subplot(gs[i, 1])

    subsignal = signal[secs[i][0]:secs[i][1]]
    Subsignal = np.fft.fft(subsignal)[1:800]
    f = np.linspace(0,sampling_rate,subsignal.shape[0])[1:800]
    ic = np.argmax(np.abs(Subsignal))
    fc = f[ic]
    frecuencias.append(fc)

    ax0.plot(t[secs[i][0]:secs[i][1]],np.abs(subsignal))
    ax0.set_xlabel('Tiempo (s)')
    ax0.set_title('Seccion '+str(i+1))
    ax0.grid()

    ax1.plot(f,np.abs(Subsignal))
    ax1.set_xlabel('Frecuencia (Hz)')
    ax1.set_title('Frecuencia principal:'+str(fc)[:5])
    ax1.grid()

"""El componente de frecuencia más significativo en algunas ocasiones es el segundo o tercer armónico."""

#EMPIECE  SU CODIGO AQUI

#CALCULE Y APLIQUE EL DESPLAZAMIENTO FRECUENCIAL
#GRAFIQUE EL ESPECTRO FRECUENCIAL ANTES Y DESPUES DEL DESPLAZAMIENTO 
#GRABE LA SEÑAL EN ESTEREO USANDO LA PARTE REAL PARA EL CANAL L Y LA PARTE IMAGINARIA EL CANAL R

!pip install wavio
!pip install audio2numpy

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import wavio
from audio2numpy import open_audio

#Frecuencias deseadas
f_deseadas = [
    261.63, # 130.81*2
    494.43, # 164.81*3
    392, # 196*2
    523.26, # 261.63*2
    392, # 196*2
    164.81, 
    261.62 # 130.81*2
]

#Ventanas de tiempo
secs = [
    [15000, 61000],
    [95000, 137000],
    [171000, 215000],
    [250000, 290000],
    [328000, 372000],
    [410000, 453000],
    [497000, 535000]
]

fig = plt.figure(constrained_layout=True, figsize = (12,20))

signal, sampling_rate = open_audio('/content/aud2.mp3')

total_size = signal.shape[0]
t = np.arange(0, total_size/sampling_rate, 1/sampling_rate)

num_secs = len(secs)
gs = gridspec.GridSpec(num_secs, 2, figure=fig)

frecuencias = []

signalFinal = signal

print(f_deseadas)

for i in range(num_secs):
    #Subplots
    ax0 = fig.add_subplot(gs[i, 0])
    ax1 = fig.add_subplot(gs[i, 1])

    #Identificacion de frecuencia principal sin desplazar
    subsignal = signal[secs[i][0]:secs[i][1]]
    Subsignal1 = np.fft.fft(subsignal)[1:800]
    f = np.linspace(0,sampling_rate,subsignal.shape[0])[1:800]
    ic = np.argmax(np.abs(Subsignal1))
    fc1 = f[ic]

    #Calculo de desplazamiento frecuencial
    delta=f_deseadas[i]-fc1

    #Desplazamiento frecuencial
    subsignal = np.exp(2j*np.pi*delta*t[secs[i][0]:secs[i][1]])*signal[secs[i][0]:secs[i][1]]
    Subsignal2 = np.fft.fft(subsignal)[1:800]

    #Identificacion de frecuencia principal desplazada
    f = np.linspace(0,sampling_rate,subsignal.shape[0])[1:800]
    ic = np.argmax(np.abs(Subsignal2))
    fc2 = f[ic]

    #Adicion de la parte desplazada en frecuencia a la señal final
    signalFinal[secs[i][0]:secs[i][1]]=subsignal

    #Adicion de frecuencia principal a lista
    frecuencias.append(fc2)

    # ax0.plot(t[secs[i][0]:secs[i][1]],np.abs(subsignal))
    # ax0.set_xlabel('Tiempo (s)')
    # ax0.set_title('Seccion '+str(i+1))
    # ax0.grid()

    #Grafica de espectro antes del desplazamiento
    ax0.plot(f,np.abs(Subsignal1))
    ax0.set_xlabel('Frecuencia (Hz)')
    ax0.set_ylabel('Magnitud')
    ax0.set_title('Espectro antes del desplazamiento, frecuencia principal:'+str(fc1)[:6])
    ax0.grid()

    #Grafica de espectro despues del desplazamiento
    ax1.plot(f,np.abs(Subsignal2))
    ax1.set_xlabel('Frecuencia (Hz)')
    ax1.set_ylabel('Magnitud')
    ax1.set_title('Espectro despues del desplazamiento, frecuencia principal:'+str(fc2)[:6])
    ax1.grid()

#Grafica de señal en tiempo despues del desplazamiento
plt.figure()
plt.plot(t,np.abs(signalFinal))
plt.xlabel('Tiempo (s)')
plt.title('Señal final')
plt.show()

#Grabacion de señal
wavio.write("aud2_cambiado.mp3", signalFinal, sampling_rate, sampwidth=1)

# wavio.write("aud2_cambiado.mp3", np.vstack((np.imag(signalFinal),np.real(signalFinal))).T, sampling_rate, sampwidth=1)
#guardar cada una en un archivo
#pueden ocurrir errores por redondeo, esos valores no van a ser exactos, acercarse lo mayor a frecuencia de referencia